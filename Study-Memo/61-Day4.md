# 61-Day4
## 1 排序算法：中值与选择

- 问题：找到无序向量中第k大的数。可以把向量MergeSort之后返回秩为k的，但这个复杂度为$O(n\log n)$
- MinSoFar算法：用$O(n)$的时间选出当前最小的元素（记录下最小的元素记下即可），但用这个算法选中值复杂度$O(n^2)$。
- 新算法：分治的思路——选择一个支点，看支点两侧小于支点的数的个数，如果恰好等于k，返回支点；否则，在左侧或右侧（取决于两侧小于支点的数的个数：左侧小于的数目>k-1在左边找，否则去右边找）递归寻找。
- 寻找支点：把向量按5个一份分成若干份，在每个5个一份中的找中位数，再找这些中位数的中位数作为支点。只有按5个一份分的时候效果最好。
- 复杂度$T(n)=T(n/5)+T(7n/10)+O(n)$，最后计算出来的复杂度为$O(n)$。虽然是$O(n)$但常数项比较大，所以实际运行时间挺长的，除非n非常大，否则不比MergeSort快。



## 2 B+ Trees
- 用于索引的数据结构
- B+树：IO成本最低 B树索引的实现其实就是借助B+树；结构特点：与2-3-4树非常类似，不同点在于父节点的数据会出现在子节点中，叶节点从左到右是排好序的全部keys，互相之间彼此相连，都存储了指向key对应信息的指针，可以通过底层叶节点遍历key对应的信息。
- B+树节点：最多n+1 pointers and n keys，但也不能让节点太空。
- 插入：
	- 叶节点有空间：直接插入
	- 叶节点溢出：按规则插入至上一非叶节点中
	- 非叶节点溢出：增加新节点，并把key放入上层节点中
	- 新的根：如果上述过程一直导致上层节点持续溢出，需要创建新的root
- 删除：简单情况、与同层节点合并、keys的重分配、换用新的根；但删除因为太复杂很少在算法中实现。
- 变种：B-tree：无重复节点（父节点的数据不会重复出现在子节点中），指向信息的指针直接在父节点中，因此不再能通过底层节点的彼此联系遍历key对应的全部信息。



## 3 哈希表（Hashing tables）
- 全集U，大小为M，M中的n个元素会被选中$M>>n$。哈希函数h：$U\rightarrow\{1,...,n\}$.可以看作用n个桶存了M个数。桶里的元素通过链表连接。
- 好的哈希表：没有太多桶（空间），每个桶中的元素数量比较平衡（都近似为$O(1)$）。但确定的哈希函数都做不到这一点。对于一个确定的哈希函数，总能让它不平衡。因此要随机地选哈希函数。
- 均匀分布的哈希函数所需的空间太大了，所以要取一个更小的哈希函数族，满足对两个不同的东西，这两个东西被放入同一个桶的概率小于等于1/n.——通用哈希函数里随机选一个函数
- 能实现$O(1)$时间里的插入、删除和查找。

